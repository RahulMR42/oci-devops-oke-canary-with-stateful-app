An illustration of OCI Deployment Canary strategy with a stateful application.---Context-------- The illustration provides a deployment flow of a sample application with a stateful data source shared across .- The deployment follows [OCI Canary Deployment strategy model](https://docs.oracle.com/en/solutions/plan-mad-strats-devops/understand-depoyment-architectures.html#GUID-1E607CF8-3446-476F-9372-355937F209ED).- Objective herer to ensure data consistency across canary and production stages (with in the same stateful datasource).- Here the focus is only for OCI Deployment pipeline ,but the same can be integrated along with other OCI devops services as well (Build,Code repo etc)![](images/oci_context.png)Application catography---- Sample application build using Guestbook app - https://kubernetes.io/docs/tutorials/stateless-application/guestbook/ - Stateful database is build using redis - inspired by blog by Okteto -  https://www.okteto.com/blog/connect-applications-across-namespaces/ - We will be using Oracle Kubernetes Engine (OKE) for application deployment.Procedure---- Create an OCI Dynamic group and add below rules.```ALL {resource.type = 'devopsdeploypipeline', resource.compartment.id = 'ocid1.compartment.xxxx'}```- Create an OCI Policy as below.```Allow dynamic-group <DG NAME> to manage repos in compartment <COMPARTMENT NAME>Allow dynamic-group <DG NAME> to manage generic-artifacts in compartment <COMPARTMENT NAME>Allow dynamic-group <DG NAME> to use ons-topics in compartment <COMPARTMENT NAME>Allow dynamic-group <DG NAME> to read all-artifacts in compartment <COMPARTMENT NAME>Allow dynamic-group <DG NAME> to manage cluster-family in compartment <COMPARTMENT NAME>```- Create an OCI Container registry repo (enable as public repo ) - https://docs.oracle.com/en-us/iaas/Content/Registry/home.htm![](images/oci_container_registr.png)- Create an OKE - https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengcreatingclusterusingoke_topic-Using_the_Console_to_create_a_Quick_Cluster_with_Default_Settings.htm#create-quick-cluster![](images/oci_oke.png)- We are using NGINX to switch the traffic between two namespaces (Canary and Production).- To do so , Use ``Access Cluster option `` of OKE ,launch the cloud shell and set the config to access the cluster.![](images/oci_oke_access_cluster.png)- We will be following the procedure mentioned [here](https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengsettingupingresscontroller.htm) to setup the ingress controller.```$ kubectl create clusterrolebinding <my-cluster-admin-binding> --clusterrole=cluster-admin --user=<user-OCID>$ export version="Latest Nginix release version " - https://github.com/kubernetes/ingress-nginx#support-versions-table$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-${version}/deploy/static/provider/cloud/deploy.yaml$ Validate the Nginx installation.```![](images/oci_nginx_validation.png)- Create the docker images and push to the OCI Artifact registry```markdown$ git clone <REPO URL>$ cd <REPO NAME>/$ docker build -t <OCI REGION>.ocir.io/<NAMESPACE>/<REPO NAME>:v0 -f Dockerfile_v0 . # Create image with version V0.$ docker build -t <OCI REGION>.ocir.io/<NAMESPACE>/<REPO NAME>:v0 -f Dockerfile_v1 . # Create image with version V1.$ docker push <OCI REGION>.ocir.io/<NAMESPACE>/<REPO NAME> # Push both the images back to the OCI artifact repo.```- Validate the images are visible under the Container registry repo created.![](images/oci_container_images.png)- Create an OCI Notification topic which will be associated with devops project - https://docs.oracle.com/en-us/iaas/Content/Notification/home.htm- Create a new Devops Project - https://docs.oracle.com/en-us/iaas/Content/devops/using/devops_projects.htm![](images/oci_projecta.png)- Ensure to enable logs for the OCI Devops Projects.![](images/oci_devops_logs.png)- Create an OCI Devops environment (type as Oracle Kubernetes Engine) - https://docs.oracle.com/en-us/iaas/Content/devops/using/create_oke_environment.htm![](images/oci_devops_env.png)- Create an OCI devops artifact with type 'Kubernetes manifest' and store the artifacts from file [guestbook_app.yaml](appConfig/guestbook_app.yml)![](images/oci_artifact_guestbook.png)- Create another  OCI devops artifact with type 'Kubernetes manifest' and store the artifacts from file [redis.yaml](appConfig/redis.yml)![](images/oci_artifact_redis.png)- Create an OCI deployment pipeline for the Redis DB deployment.- With in the deployment pipeline add a deployment stage as type `Apply manifest to Your Kubernetes`![](images/oci_deploy_stagea.png)- Associate with the `OKE devops environment` and `Redis.yaml` artifact . Use the namespace as `ns-prod` to deploy the DB under production namespace.![](images/oci_deploy_stage_redis.png)- Create anothe OCI devops deployment pipeline for the application with Canary deployment.- Use 'Canary Strategy' as the stage type.![](images/oci_canary_stage.png)- Select the deployment type as OKE , use `ns-canary` as canary namespace and and `ns-prod` for production namespace.- Associate it with the guest book artifacts created.![](images/oci_oke_canary_1.png)- Use `guestbook-ingress` as the NGINX ingress name.- Use ramp limit as 25% under canary shift so that 25 % of traffic will be served via the new version.![](images/oci_oke_canary_2.png)- You may skipp the validation step and add at least one as approval count .![](images/oci_oke_canary_3.png)![](images/oci_oke_canary_4.png)- The final view of deployment pipeline is as below .![](images/oci_deploymentpipeline_guestbook.png)- Let us do the db deployment , to do so ,use the `redis db` pipeline created and execute it via `Run pipelineoption.![](images/oci_redis_dbdeployment.png)- Wait for all the steps to complete .![](images/oci_redis_deploy_steps.png)- Validate the redis deployment using `kubectl` over cloudshell .```markdown$ kubectl get all -n ns-prod |grep -i redis$ kubectl logs -n ns-prod pod/redis-0```![](images/oci_kubectl_redis.png)- Switch to the deployment pipeline created for guestbook.- Add two deployment parameters as below ```markdown- "version" with no default value ,its the docker image version that will be used .- "redis_hosts" with default value as redis.ns-prod.svc.cluster.local ,its the service endpoint to access the redis db. ```![](images/oci_deploy_param.png)- Do a manual run of the guestbook deployment pipeline with image version as `v0`.![](images/oci_deploy_guestbook1.png)- Since its the first deployment  we wont be seeing any canary shift as it needs ingress controller to be established (at least one time) with in the namespaces.- So approve the stage annd complete untill the last step for the deployment.![](images/oci_deploy_approval.png)![](images/oci_deploy_approved.png)- Wait for all the deployment steps to complete .![](images/oci_deployment_all_steps.png)- To validate the application ,switch to `OCI Cloud shell and use Kubectl`.```markdown$ kubectl get all,ing -n ns-prod```![](images/oci_kubectl_geting.png)- Fetch the Ingress public ip and use a browser to view the application .![](images/oci_guestbook_app.png)- Please note you may have a different color ,which is perfectly ok ,but if you see an error stating `Waiting for DB connection` , recheck your redis_url and redis deployment ,as it is unable to connect to the data base- Let us add some data to the application and press submit.![](images/oci_app_data.png)